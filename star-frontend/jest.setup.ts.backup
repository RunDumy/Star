import '@testing-library/jest-dom';
import fetchMock from 'jest-fetch-mock';
import React from 'react';

// Enable fetch mocking
fetchMock.enableMocks();

// Mock process.env
process.env.VITE_API_URL = 'http://localhost:5000';

// Mock Konva Stage for canvas testing
jest.mock('konva', () => ({
  Stage: jest.fn().mockImplementation(() => ({
    toDataURL: jest.fn().mockReturnValue('data:image/png;base64,mock_image_data'),
  })),
}));

// Mock tsparticles modules
jest.mock('tsparticles', () => ({
  loadFull: jest.fn().mockResolvedValue(null),
}));

jest.mock('react-tsparticles', () => {
  return jest.fn(({ children }) => children);
});

// Mock React Spring Three.js
jest.mock('@react-spring/three', () => ({
  animated: {
    mesh: 'mesh',
    group: 'group',
    meshStandardMaterial: 'meshStandardMaterial',
  },
  useSpring: jest.fn(() => [
    {
      scale: [1, 1, 1],
      position: [0, 0, 0],
      rotation: [0, 0, 0],
      emissiveIntensity: 0.2
    },
    {
      start: jest.fn(),
      stop: jest.fn(),
      set: jest.fn()
    }
  ]),
  useSpringValue: jest.fn(() => ({ set: jest.fn(), get: jest.fn() })),
  config: {
    default: {},
    gentle: {},
    slow: {},
  },
}));

// Mock @react-three/fiber
jest.mock('@react-three/fiber', () => ({
  useFrame: jest.fn(),
  useThree: jest.fn(() => ({
    camera: { position: { set: jest.fn() }, lookAt: jest.fn() },
    scene: { add: jest.fn(), remove: jest.fn() },
    gl: { domElement: { tagName: 'CANVAS', width: 800, height: 600 } },
    raycaster: {
      setFromCamera: jest.fn(),
      intersectObjects: jest.fn().mockReturnValue([]),
    },
  })),
  Canvas: jest.fn(({ children }) => children),
}));

// Mock @react-three/drei
jest.mock('@react-three/drei', () => ({
  Text: jest.fn(({ children }) => children),
  OrbitControls: jest.fn(() => null),
  Stars: jest.fn(() => null),
}));

// Mock navigator clipboard
Object.assign(navigator, {
  clipboard: {
    writeText: jest.fn().mockImplementation(() => Promise.resolve()),
  },
});

// Mock Supabase client
jest.mock('./src/lib/supabase', () => ({
  supabase: {
    from: jest.fn().mockReturnValue({
      select: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      update: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn().mockResolvedValue({ data: null, error: null }),
    }),
    auth: {
      getUser: jest.fn().mockResolvedValue({ data: { user: null }, error: null }),
      signIn: jest.fn().mockResolvedValue({ data: null, error: null }),
      signOut: jest.fn().mockResolvedValue({ error: null }),
    },
  },
  getProfile: jest.fn().mockResolvedValue(null),
  updateProfile: jest.fn().mockResolvedValue(null),
}));

// Mock HTMLAnchorElement click
Object.defineProperty(HTMLAnchorElement.prototype, 'click', {
  writable: true,
  value: jest.fn(),
});

// Mock URL.createObjectURL
global.URL.createObjectURL = jest.fn(() => 'mock-object-url');
global.URL.revokeObjectURL = jest.fn();

// Mock IntersectionObserver
global.IntersectionObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  disconnect: jest.fn(),
  unobserve: jest.fn(),
}));

// Mock ResizeObserver
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  disconnect: jest.fn(),
  unobserve: jest.fn(),
}));

// Mock window.alert in jsdom environment to avoid 'Not implemented: window.alert' errors
if (typeof window !== 'undefined') {
  // Replace any existing alert (jsdom's placeholder throws) with a no-op jest mock
  // so tests can call alert without causing an exception.
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  window.alert = jest.fn();
}

// Suppress specific console.error messages that are expected in jsdom/test env
const originalError = console.error;
console.error = (...args: any[]) => {
  if (typeof args[0] === 'string') {
    const msg: string = args[0];
    if (
      msg.includes('Not implemented: window.alert') ||
      msg.includes('not wrapped in act(') ||
      msg.includes('Function components cannot be given refs')
    ) {
      return;
    }
  }
  originalError.call(console, ...args);
};

// Suppress console warnings during tests
const originalWarn = console.warn;
console.warn = (...args) => {
  if (
    typeof args[0] === 'string' &&
    (args[0].includes('Warning: ReactDOM.render is deprecated') ||
      args[0].includes('Warning: ReactDOMTestUtils has been moved'))
  ) {
    return;
  }
  originalWarn.call(console, ...args);
};

// Mock useCosmicTheme hook
jest.mock('./src/contexts/CosmicThemeContext', () => ({
  useCosmicTheme: jest.fn(() => ({
    theme: {
      backgroundColor: '#000011',
      fogColor: '#000033',
      ambientColor: '#ffffff',
      pointLightColor: '#ffffff',
      terrainColor: '#4a4a8a',
      terrainEmissive: '#2a2a5a',
      starDensity: 8000,
      starSize: 6,
      animationSpeed: 1,
      ambientIntensity: 0.3,
      pointLightIntensity: 0.8,
      particleColors: ['#ff4444', '#87CEEB', '#4361ee', '#8B4513'],
      geometry: {
        planetShape: 'sphere'
      }
    },
    updateTheme: jest.fn(),
    setPreset: jest.fn(),
    dispatch: jest.fn()
  })),
  CosmicThemeProvider: ({ children }: { children: React.ReactNode }) => children,
}));

// Mock useCollaboration hook
jest.mock('./src/contexts/CollaborationContext', () => ({
  useCollaboration: jest.fn(() => ({
    onlineUsers: new Map([
      ['test-user', { id: 'test-user', name: 'Test User', galactic_tone: 1 }],
      ['user-1', { id: 'user-1', name: 'User 1', galactic_tone: 2 }]
    ]),
    currentUser: { id: 'test-user', name: 'Test User' },
    updateUserPosition: jest.fn(),
    socket: {
      emit: jest.fn(),
      on: jest.fn(),
      off: jest.fn(),
    },
    triggerZodiacAction: jest.fn().mockResolvedValue({}),
    recentActions: [],
    constellations: []
  })),
  CollaborationProvider: ({ children }: { children: React.ReactNode }) => children,
}));

// Mock @use-gesture/react
jest.mock('@use-gesture/react', () => {

  return {
    useGesture: jest.fn((handlers: any) => {
      // Return a function that returns gesture props
      return () => {
        const gestureProps: any = {};

        if (handlers.onDrag) {
          gestureProps.onPointerDown = (event: any) => {
            // Store start position and call handler with first state
            // For testing, we need to access the props passed to fireEvent
            const startX = event.nativeEvent?.clientX || event.clientX || event.target?.getBoundingClientRect?.()?.left || 100;
            const startY = event.nativeEvent?.clientY || event.clientY || event.target?.getBoundingClientRect?.()?.top || 100;

            console.log('Mock onPointerDown - full event:', event, 'extracted:', { startX, startY });
            mockGestureHandlers.set(event.currentTarget, { startX, startY, handlers });

            const dragState = {
              down: true,
              first: true,
              last: false,
              active: true,
              movement: [0, 0],
              offset: [0, 0],
              xy: [startX, startY],
              direction: [0, 0],
              distance: 0,
              velocity: [0, 0],
              event
            };
            handlers.onDrag(dragState);
          }; gestureProps.onPointerMove = (event: any) => {
            const data = mockGestureHandlers.get(event.currentTarget);
            if (data) {
              const currentX = event.clientX || 0;
              const currentY = event.clientY || 0;
              const movementX = currentX - data.startX;
              const movementY = currentY - data.startY;

              console.log('Mock onPointerMove - event:', { clientX: event.clientX, clientY: event.clientY, currentX, currentY }, 'start:', { startX: data.startX, startY: data.startY }, 'movement:', [movementX, movementY]);

              const dragState = {
                down: true,
                first: false,
                last: false,
                active: true,
                movement: [movementX, movementY],
                offset: [movementX, movementY],
                xy: [currentX, currentY],
                direction: [movementX > 0 ? 1 : -1, movementY > 0 ? 1 : -1],
                distance: Math.sqrt(movementX * movementX + movementY * movementY),
                velocity: [Math.abs(movementX) > 10 ? 1 : 0, Math.abs(movementY) > 10 ? 1 : 0],
                event
              };
              console.log('Mock onPointerMove - movement:', [movementX, movementY], 'threshold check:', Math.abs(movementX) > 50 || Math.abs(movementY) > 50);
              data.handlers.onDrag(dragState);
            }
          };

          gestureProps.onPointerUp = (event: any) => {
            const data = mockGestureHandlers.get(event.currentTarget);
            if (data) {
              const movementX = event.clientX - data.startX;
              const movementY = event.clientY - data.startY;

              const dragState = {
                down: false,
                first: false,
                last: true,
                active: false,
                movement: [movementX, movementY],
                offset: [movementX, movementY],
                xy: [event.clientX, event.clientY],
                direction: [movementX > 0 ? 1 : -1, movementY > 0 ? 1 : -1],
                distance: Math.sqrt(movementX * movementX + movementY * movementY),
                velocity: [Math.abs(movementX) > 10 ? 1 : 0, Math.abs(movementY) > 10 ? 1 : 0],
                event
              };
              console.log('Mock onPointerUp - movement:', [movementX, movementY], 'threshold check:', Math.abs(movementX) > 50 || Math.abs(movementY) > 50);
              data.handlers.onDrag(dragState);

              // Clean up
              mockGestureHandlers.delete(event.currentTarget);
            }
          };
        }

        return gestureProps;
      };
    })
  };
});
